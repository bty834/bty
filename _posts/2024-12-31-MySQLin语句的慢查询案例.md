---
title: MySQL in语句慢查询
categories: [编程,MySQL]
tags: [mysql]
---

UPDATE tb_xxx_info SET bid = 123456789 WHERE sn IN (31651个值) and type in( 'xx');

in (过多) 全表扫描

上图5.7的explain查看执行计划时，有warning信息，如下：
| Level   | Code | Message                                                                                                                       
+---------+------+-------------------------------------------------------------------------------------------------------------------------------
| Warning | 3170 | Memory capacity of 8388608 bytes for 'range_optimizer_max_mem_size' exceeded. Range optimization was not done for this query.
看起来和range_optimizer_max_mem_size有关。MySQL官方文档的介绍如下：
The limit on memory consumption for the range optimizer. A value of 0 means “no limit.” If an execution plan considered by the optimizer uses the range access method but the optimizer estimates that the amount of memory needed for this method would exceed the limit, it abandons the plan and considers other plans. For more information, see Limiting Memory Use for Range Optimization.

大致意思是，优化器在评估range执行计划的时候，如果需要的内存超过range_optimizer_max_mem_size的值的限制时，会舍弃range类型的执行计划，退化到选择其他执行计划，包括全表扫描。

https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#range-optimization-memory-use

这个“feature”自MySQL range访问方法出现的时候就有，只不过5.6的时候是hard code的，允许的IN的值多一些；超过一定的数量后，也会和5.7一样，可能退化到全表扫描。详细可参考《Using many WHERE conditions makes range scan disabled》https://bugs.mysql.com/bug.php?id=70247
5.7.9的时候，引入了参数 range_optimizer_max_mem_size，以便控制range优化器消耗的内存限制。详见：https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-9.html

以上SQL查询场景，也属于IN的个数特别多的情况了，肯定会慢查询，一般建议业务优化减少IN的个数。不建议线上调整此参数的默认值（8388608），如果升级时遇到类似情况，建议先调大range_optimizer_max_mem_size的值，临时解决问题，长久来看还是要推动业务优化减少IN的值个数。


---


show profile block io,cpu,context switches, PAGE FAULTS for query 7


---
or vs in

很多数据库里In和or是等价的，因为他们逻辑是相等的。
但是在MySQL中会对in中的列表排序，排序用的是二分查找来判断是否在列表中。in的时间复杂度是O(logn)而or的时间复杂度是O(n)，这就意味着In的效率更高。
https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in

1、https://zhuanlan.zhihu.com/p/71064147；
2、https://blog.csdn.net/Asce_zz/article/details/89000975
3、https://stackoverflow.com/questions/782915/mysql-or-vs-in-performance

---
MySQL 默认排序真的是按主键来排序的吗？

https://segmentfault.com/a/1190000016251056
https://segmentfault.com/a/1190000040880890

前提：单表启用主键自增，且主键是业务不相关的。
1、根据你的查询条件，查询出满足这些查询条件的 min(id), max(id)；
2、在你的查询条件中，添加上 "id between M and N"。 建议 step=N-M 的步长，保持在 [1000,20000] 。
step 在代码中，可设置成一变量，在表中数据分布过于稀疏时，将step调大（此时 step 可适当大于 2W，保持在 10W 内）

注：此时，请将原始语句中的 “limit 1000” 或者 "limit 2700000,1000" 这种类型的关键词，从语句中去掉。

通常根据上述方式获取数据，一次查询，能在 1ms 内跑完（不是宽表）。
业务反正是轮询整张表，让每条语句都匀质的跑下去，时间可控，性能可控，对 DB 的影响可控，是个好习惯。

https://www.cnblogs.com/LBSer/p/3333881.html
