---
title: Java业务仔的常用操作
categories: [ 编程,Java ]
tags: [ java ]
---


## stream
```java
    @Data
    static class Course {
        private Long number;
        private LocalDateTime beginTime;
        private List<Long> studentIds;
    }


    public void streamOperations(List<Course> courses) {

        // 映射并去重
        List<Long> courseNumbers = courses.stream()
                .filter(Objects::nonNull)
                .map(Course::getNumber)
                .distinct()
                .collect(Collectors.toList());

        // 先按开始时间排序后按number排序
        List<Course> sortedCourses = courses.stream()
                .sorted(Comparator.comparing(Course::getBeginTime).thenComparing(Course::getNumber))
                .collect(Collectors.toList());

        // 根据number组成map, 如果有相同的number会抛异常
        Map<Long, Course> num2Lesson1 = courses.stream().collect(Collectors.toMap(Course::getNumber, Function.identity()));


        // 根据number组成map, 如果有相同的number会执行降级逻辑
        Map<Long, Course> num2Lesson2 = courses.stream().collect(Collectors.toMap(Course::getNumber, Function.identity(), (v1, v2) -> v1));

        // 根据number聚合
        Map<Long, List<Course>> num2Lessons = courses.stream()
                .filter(Objects::nonNull)
                .collect(Collectors.groupingBy(Course::getNumber));

        // 根据number聚合某个字段
        Map<Long, List<LocalDateTime>> number2BeginTimes = courses.stream()
                .filter(Objects::nonNull)
                .collect(Collectors.groupingBy(Course::getNumber,
                        Collectors.mapping(Course::getBeginTime, Collectors.toList())));

        // 根据number找到number下最大beginTime的Course
        Map<Long, Optional<Course>> number2MaxBeginTimeCourse = courses.stream()
                .filter(r -> Objects.nonNull(r.getBeginTime()))
                .collect(Collectors.groupingBy(Course::getNumber, Collectors.maxBy(Comparator.comparing(Course::getBeginTime))));

        // 获取course下所有的studentId
        List<Long> allStudentIds = courses.stream()
                .map(Course::getStudentIds)
                .flatMap(Collection::stream)
                .distinct()
                .collect(Collectors.toList());
    }
```

## guava

```java
    //  <dependency>
    //      <groupId>com.google.guava</groupId>
    //      <artifactId>guava</artifactId>
    //      <version>33.2.0-jre</version>
    //  </dependency>
    public void guavaOperations(List<Course> courses) {

        // 分批处理
        int batchSize = 100;
        for (List<Course> partList : Lists.partition(courses, 100)) {
            // partList是视图，不要做变更操作
            // do your business logic
            System.out.println(partList);
        }

        // new集合
        List<Course> list = Lists.newArrayList();
        List<Course> list2 = Lists.newArrayListWithCapacity(10);
        List<Course> list3 = Lists.newArrayListWithExpectedSize(20);
        Set<Course> set = Sets.newHashSet();
        Map<Integer, Course> map = Maps.newHashMap();

        // 范围
        Range<Integer> range = Range.closed(1, 10); // [1,10]
        Range<Integer> range2 = Range.closedOpen(1, 10); // [1,10)
        Range<Integer> range3 = Range.open(1, 10); // (1,10)
        Integer shouldBe1 = range.lowerEndpoint();
        Integer shouldBe10 = range.upperEndpoint();
        Range<Integer> intersection = range.intersection(range2);
    }
```

## commons

```java

    //    <dependency>
    //      <groupId>org.apache.commons</groupId>
    //      <artifactId>commons-collections4</artifactId>
    //      <version>4.4</version>
    //    </dependency>
    //    <dependency>
    //      <groupId>org.apache.commons</groupId>
    //      <artifactId>commons-lang3</artifactId>
    //      <version>3.14.0</version>
    //    </dependency>
    public void commons(String str, List<Course> courses, Set<Course> set, Map<Long, Course> map){

        boolean notEmpty = CollectionUtils.isNotEmpty(courses);
        boolean notEmpty2 = CollectionUtils.isNotEmpty(set);
        boolean notEmpty3 = MapUtils.isNotEmpty(map);

        boolean notBlank = StringUtils.isNotBlank(str);

        Pair<Long, Course> number2Course = Pair.of(1L, new Course());
        Triple<Long, Long, Course> triple = Triple.of(1L, 2L, new Course());

    }
```
